# Планирование инфраструктуры БД.

## 1. Определение требований

### Бизнес-требования

Этот этап определяет, **что** и **как** данные будут использоваться для поддержки бизнес-процессов.

* **Объем данных и рост:** Оценка текущего размера данных и прогнозирование роста (например, 1 ТБ данных, рост 200 ГБ в год). Это влияет на выбор дисковой системы и необходимости в горизонтальном масштабировании.
* **Типы данных:** Понимание, храним ли мы простые таблицы (`String`, `Int`), сложные JSON-объекты, или данные с привязкой ко времени/географии.
* **Функциональные требования:** Определение преобладающих операций (например, 80% — чтение, 20% — запись; или высокая частота сложных транзакций).

### Нефункциональные требования

Эти требования определяют **качество** системы и её поведение в различных условиях.

* **Производительность:** Измеряется в **Latency** (задержка отклика, например, менее 100 мс) и **Throughput** (пропускная способность, количество операций в секунду — QPS).
* **Надежность и доступность:** Определяется **SLA** (Service Level Agreement), **RTO** (Recovery Time Objective — время восстановления после сбоя) и **RPO** (Recovery Point Objective — максимальный допустимый объем потери данных).
* **Безопасность:** Включает защиту данных от несанкционированного доступа.

## 2. Выбор типа БД

Выбор основывается на типе данных и требуемой модели доступа.

* **Реляционные (SQL):** Используют таблицы со строгой схемой. Идеальны для систем, где важна **ACID**-транзакционность (Atomicity, Consistency, Isolation, Durability) и сложные связи между данными.
* **Документоориентированные (NoSQL):** Хранят данные в гибких JSON- или BSON-документах. Хороши для быстро меняющихся данных или когда структура данных не стандартизирована.
* **Ключ-значение:** Простейшая модель (ключ \to значение). Используются для высокоскоростного кэширования, хранения сессий и простых счетчиков, где важна минимальная задержка.
* **Графовые БД:** Хранят данные как узлы (сущности) и ребра (связи). Оптимизированы для запросов, связанных с отношениями (например, "найти всех друзей друзей").
* **Временные ряды:** Специализированные БД для хранения данных, где каждый элемент привязан к временной метке. Оптимизированы для записи больших объемов данных по времени и агрегации по интервалам.

## 3. Архитектура и развертывание

Этот этап определяет, как физически будут расположены и взаимодействовать компоненты БД.

* **Монолитная vs распределённая:**
* **Монолитная:** Вся БД работает на одном сервере. Просто в управлении, но имеет потолок масштабируемости.
* **Распределённая:** Данные разделены между несколькими узлами (шардинг) или дублированы (репликация). Сложнее в управлении, но обеспечивает высокую доступность и горизонтальное масштабирование.


* **Масштабирование:**
* **Вертикальное (Scale-up):** Увеличение мощности (CPU, RAM, диски) одного сервера. Быстро, но дорого и ограничено.
* **Горизонтальное (Scale-out):** Добавление новых, часто более дешевых, узлов. Обеспечивает почти неограниченный рост.


* **Резервирование и отказоустойчивость:**
* **Репликация (Master-Slave/Leader-Follower):** Данные копируются с основного узла на резервные. Повышает доступность для чтения и обеспечивает возможность быстрого переключения.
* **Failover:** Автоматический процесс, при котором резервный узел берет на себя роль основного в случае сбоя.


* **Бэкапы:** Стратегия создания копий данных. Должны включать полные (вся БД) и инкрементные (только изменения с последнего бэкапа) копии, хранимые отдельно от рабочей системы (на удалённых хранилищах).

## 4. Проектирование структуры данных

Это создание эффективного макета для хранения данных.

* **Нормализация / Денормализация:**
* **Нормализация:** Устранение избыточности данных, разделение на множество таблиц с ключами. Улучшает целостность данных, но может замедлять чтение (требуется много JOIN'ов).
* **Денормализация:** Введение избыточности для ускорения запросов на чтение. Часто используется в аналитических БД.


* **Индексы:** Структуры, ускоряющие поиск данных по определенным столбцам. Неправильное использование (слишком много индексов или индексы на неиспользуемых полях) замедляет операции записи.
* **Ограничения целостности:** Правила, которые СУБД применяет для обеспечения точности и надежности данных (например, `FOREIGN KEY` для связей, `UNIQUE` для уникальных значений, `CHECK` для проверки условий).
* **Оптимизация OLTP vs OLAP:**
* **OLTP (Online Transaction Processing):** Оптимизация для быстрых, коротких транзакций (запись, обновление, небольшое чтение).
* **OLAP (Online Analytical Processing):** Оптимизация для сложных, ресурсоемких запросов, считывающих большие объемы данных (отчетность, аналитика).



## 5. Безопасность и доступ

Защита данных на всех уровнях.

* **Роли и привилегии:** Принцип наименьших привилегий (Least Privilege) — пользователь или приложение должны иметь доступ только к тем данным и операциям, которые им строго необходимы.
* **Шифрование:**
* **At Rest (в покое):** Шифрование данных, хранящихся на диске (TDE — Transparent Data Encryption).
* **In Transit (при передаче):** Использование SSL/TLS для защиты сетевого трафика между приложением и БД.


* **Логи и аудит:** Запись всех значимых действий (например, попыток доступа, изменения привилегий) для последующего анализа безопасности.
* **Защита от атак:** Настройка фаерволов, ограничение доступа к сети, использование подготовленных запросов (Prepared Statements) для предотвращения SQL-инъекций.

## 6. Мониторинг и эксплуатация

Поддержание здоровья и производительности системы после запуска.

* **Метрики производительности:** Сбор количественных показателей, чтобы знать, когда система начинает работать плохо:
* **QPS (Queries Per Second):** Сколько запросов обрабатывается.
* **Latency:** Время ответа.
* **Load:** Загрузка сервера (CPU, I/O).
* **Storage:** Использование дискового пространства.


* **Инструменты мониторинга:** Использование специализированных систем (например, Prometheus для сбора метрик, Grafana для их визуализации) для создания дашбордов и оповещений.
* **План обслуживания:** Регулярное выполнение задач, таких как оптимизация индексов, очистка логов, применение патчей безопасности и тестирование сценариев масштабирования/восстановления.

## 7. Документация и стандарты

Обеспечение управляемости и преемственности знаний.

* **ER-диаграммы (Entity-Relationship):** Визуальная схема, показывающая, как сущности (таблицы) и их атрибуты связаны друг с другом.

* **Стандарты именования:** Единообразные правила для названий таблиц, колонок и процедур (например, использование нижнего подчеркивания `user_profile` или CamelCase `userProfile`). Это критически важно для командной работы.
* **Руководство по использованию и бэкапам:** Четкие инструкции для разработчиков (как правильно подключаться и писать запросы) и для администраторов (как восстанавливать БД из резервной копии).
